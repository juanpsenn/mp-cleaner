<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transaction Parser</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 1.1em;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #444;
            font-weight: 600;
            font-size: 0.95em;
        }

        select, input[type="file"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        select:focus, input[type="file"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-label {
            display: block;
            padding: 12px 15px;
            background: #f8f9fa;
            border: 2px dashed #d0d0d0;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-input-label:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-name {
            margin-top: 8px;
            color: #667eea;
            font-size: 0.9em;
            font-weight: 500;
        }

        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 10px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .results {
            margin-top: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 2px solid #e0e0e0;
        }

        .results h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .currency-section {
            margin-bottom: 25px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .currency-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .currency-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #667eea;
        }

        .transaction-count {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .transaction-preview {
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9em;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .transaction-row {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            display: grid;
            grid-template-columns: 100px 1fr 100px;
            gap: 15px;
        }

        .transaction-row:last-child {
            border-bottom: none;
        }

        .transaction-date {
            color: #666;
            font-weight: 500;
        }

        .transaction-desc {
            color: #333;
        }

        .transaction-amount {
            text-align: right;
            font-weight: 600;
        }

        .transaction-amount.positive {
            color: #22c55e;
        }

        .transaction-amount.negative {
            color: #ef4444;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .action-buttons button {
            margin-top: 0;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border: 2px solid #fcc;
        }

        .success {
            background: #efe;
            color: #3c3;
            padding: 12px 15px;
            border-radius: 8px;
            margin-top: 10px;
            border: 2px solid #cfc;
            text-align: center;
            font-weight: 500;
        }

        .info {
            background: #e3f2fd;
            color: #1976d2;
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #bbdefb;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .results {
            animation: fadeIn 0.4s ease-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState } = React;

        // TypeScript-like types defined in JSDoc comments

        /**
         * @typedef {'ARS' | 'USD'} Currency
         */

        /**
         * @typedef {Object} Transaction
         * @property {Date} date
         * @property {string} description
         * @property {number} amount
         * @property {Currency} currency
         */

        /**
         * @typedef {Object} TransactionBatch
         * @property {Transaction[]} transactions
         * @property {Currency} currency
         * @property {string} provider
         */

        /**
         * @typedef {'santander' | 'mercadopago'} BankType
         */

        // Parser implementations

        class BaseParser {
            constructor(file) {
                this.file = file;
            }

            async parse() {
                const rawData = await this.readFile();
                const transactions = await this.extractTransactions(rawData);
                const validTransactions = this.validateTransactions(transactions);
                return this.groupByCurrency(validTransactions);
            }

            validateTransactions(transactions) {
                return transactions.filter(t => t.description && t.description.trim() !== '');
            }

            groupByCurrency(transactions) {
                const batches = {};

                transactions.forEach(transaction => {
                    const currency = transaction.currency;
                    if (!batches[currency]) {
                        batches[currency] = {
                            transactions: [],
                            currency: currency,
                            provider: this.getProviderName()
                        };
                    }
                    batches[currency].transactions.push(transaction);
                });

                // Sort by date (newest first)
                Object.values(batches).forEach(batch => {
                    batch.transactions.sort((a, b) => b.date - a.date);
                });

                return batches;
            }

            async readFile() {
                throw new Error('Must implement readFile');
            }

            async extractTransactions(rawData) {
                throw new Error('Must implement extractTransactions');
            }

            getProviderName() {
                throw new Error('Must implement getProviderName');
            }
        }

        class SantanderParser extends BaseParser {
            getProviderName() {
                return 'santander';
            }

            async readFile() {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: '' });
                            resolve(jsonData);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(this.file);
                });
            }

            sanitizeAmount(value) {
                if (!value || value === '') return null;

                const valueStr = String(value).trim();
                // Remove currency symbols and spaces
                const cleaned = valueStr.replace(/[U$DS\s]/g, '');
                // Replace comma with dot for decimal separator, remove dots used for thousands
                const normalized = cleaned.replace(/\./g, '').replace(/,/g, '.');

                try {
                    const amount = parseFloat(normalized);
                    return -amount; // Negate the amount
                } catch {
                    return null;
                }
            }

            formatDatePlusOne(dateValue) {
                if (!dateValue) return null;

                let date;
                if (typeof dateValue === 'string') {
                    const parts = dateValue.split('/');
                    if (parts.length === 3) {
                        date = new Date(parts[2], parts[1] - 1, parts[0]);
                    } else {
                        return null;
                    }
                } else if (typeof dateValue === 'number') {
                    // Excel date number
                    date = new Date((dateValue - 25569) * 86400 * 1000);
                } else {
                    date = new Date(dateValue);
                }

                // Add 1 day
                date.setDate(date.getDate() + 1);
                return date;
            }

            buildDescription(cuotas, descripcion, comprobante) {
                const parts = [];

                if (descripcion && descripcion !== '' && descripcion !== '-') {
                    let desc = String(descripcion).trim();
                    if (desc.endsWith(' - ')) {
                        desc = desc.slice(0, -3);
                    }
                    if (desc && desc !== '-') {
                        parts.push(desc);
                    }
                }

                if (cuotas && String(cuotas).trim() !== '' && String(cuotas).trim() !== '-') {
                    parts.push(String(cuotas).trim());
                }

                if (comprobante && String(comprobante).trim() !== '' && String(comprobante).trim() !== '-') {
                    parts.push(String(comprobante).trim());
                }

                return parts.join(' - ');
            }

            extractTransactionsFromSection(data, startRow) {
                const transactions = [];

                // Find header row
                let headerRow = null;
                for (let i = startRow; i < Math.min(startRow + 10, data.length); i++) {
                    const row = data[i];
                    if (row[0] && String(row[0]).includes('Fecha') ||
                        row[1] && String(row[1]).includes('Fecha')) {
                        headerRow = i;
                        break;
                    }
                }

                if (headerRow === null) return transactions;

                const dataStart = headerRow + 1;
                let lastValidDate = null;

                for (let i = dataStart; i < data.length; i++) {
                    const row = data[i];

                    // Check if we hit a new section
                    const firstCell = row[0] ? String(row[0]).trim() : '';
                    if (firstCell.startsWith('Tarjeta de') ||
                        firstCell.startsWith('Pago de') ||
                        firstCell.startsWith('Ãšltimos')) {
                        break;
                    }

                    // Determine column offset based on where date is
                    let fecha = null;
                    let colOffset = 0;

                    if (row[0] && String(row[0]).includes('/')) {
                        fecha = row[0];
                        colOffset = 0;
                        lastValidDate = fecha;
                    } else if (row[1] && String(row[1]).includes('/')) {
                        fecha = row[1];
                        colOffset = 1;
                        lastValidDate = fecha;
                    } else {
                        fecha = lastValidDate;
                        colOffset = 0;
                    }

                    if (!fecha) continue;

                    const descripcion = row[1 + colOffset] || '';
                    const cuotas = row[2 + colOffset] || '';
                    const comprobante = row[3 + colOffset] || '';
                    const montoPesos = row[4 + colOffset] || '';
                    const montoDolares = row[5 + colOffset] || '';

                    // Skip empty rows
                    if (!descripcion || String(descripcion).trim() === '') continue;

                    const parsedDate = this.formatDatePlusOne(fecha);
                    if (!parsedDate) continue;

                    const description = this.buildDescription(cuotas, descripcion, comprobante);

                    // ARS transaction
                    const amountArs = this.sanitizeAmount(montoPesos);
                    if (amountArs !== null) {
                        transactions.push({
                            date: parsedDate,
                            description: description,
                            amount: amountArs,
                            currency: 'ARS'
                        });
                    }

                    // USD transaction
                    const amountUsd = this.sanitizeAmount(montoDolares);
                    if (amountUsd !== null) {
                        transactions.push({
                            date: parsedDate,
                            description: description,
                            amount: amountUsd,
                            currency: 'USD'
                        });
                    }
                }

                return transactions;
            }

            async extractTransactions(rawData) {
                const allTransactions = [];

                for (let i = 0; i < rawData.length; i++) {
                    const row = rawData[i];
                    const rowStr = row.join(' ');

                    if (rowStr.includes('Pago de tarjeta y devoluciones')) {
                        const transactions = this.extractTransactionsFromSection(rawData, i);
                        allTransactions.push(...transactions);
                    } else if (rowStr.includes('Tarjeta de') && rowStr.includes('terminada en')) {
                        const transactions = this.extractTransactionsFromSection(rawData, i);
                        allTransactions.push(...transactions);
                    }
                }

                return allTransactions;
            }
        }

        class MercadoPagoParser extends BaseParser {
            getProviderName() {
                return 'mercadopago';
            }

            async readFile() {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = e.target.result;
                            // Don't filter empty lines - keep original indices like Python version
                            const lines = text.split('\n');

                            if (lines.length < 5) {
                                reject(new Error('CSV file must have at least 5 rows'));
                                return;
                            }

                            // Get header from 4th row (index 3)
                            const headerLine = lines[3].trim();

                            // Get data from 5th row onwards (index 4+), filtering empty lines
                            const dataLines = lines.slice(4).map(line => line.trim()).filter(line => line);

                            // Detect separator
                            const separator = this.detectSeparator(headerLine);

                            // Parse header and trim each header name
                            const headers = this.parseCSVLine(headerLine, separator).map(h => h.trim());

                            // Parse data rows
                            const rows = dataLines.map(line => {
                                const values = this.parseCSVLine(line, separator);
                                if (values.length === headers.length) {
                                    const row = {};
                                    headers.forEach((header, idx) => {
                                        row[header] = values[idx];
                                    });
                                    return row;
                                }
                                return null;
                            }).filter(row => row !== null);

                            resolve(rows);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(this.file, 'utf-8');
                });
            }

            detectSeparator(line) {
                let commaCount = 0;
                let semicolonCount = 0;
                let inQuotes = false;

                for (const char of line) {
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (!inQuotes) {
                        if (char === ',') commaCount++;
                        else if (char === ';') semicolonCount++;
                    }
                }

                return semicolonCount > commaCount ? ';' : ',';
            }

            parseCSVLine(line, separator = ',') {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === separator && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }

                result.push(current.trim());
                return result;
            }

            convertToInteger(argentineAmount) {
                if (!argentineAmount || argentineAmount.trim() === '') return null;

                const cleanAmount = argentineAmount.trim();
                const isNegative = cleanAmount.startsWith('-');
                const withoutSign = isNegative ? cleanAmount.slice(1) : cleanAmount;

                // Remove dots and split by comma
                const parts = withoutSign.replace(/\./g, '').split(',');

                try {
                    const integerPart = parts[0] ? parseInt(parts[0], 10) : 0;
                    return isNegative ? -integerPart : integerPart;
                } catch {
                    return null;
                }
            }

            addOneDayAndFormat(dateStr) {
                if (!dateStr || dateStr.trim() === '') return null;

                const parts = dateStr.trim().split('-');
                if (parts.length !== 3) return null;

                try {
                    const day = parseInt(parts[0], 10);
                    const month = parseInt(parts[1], 10);
                    const year = parseInt(parts[2], 10);

                    const date = new Date(year, month - 1, day);
                    date.setDate(date.getDate() + 1);

                    return date;
                } catch {
                    return null;
                }
            }

            cleanTransactionType(transactionType) {
                if (!transactionType) return '';

                const cleaned = transactionType.replace(
                    /transferencia\s+(enviada|recibida)\s*/gi,
                    ''
                );

                return cleaned.trim();
            }

            async extractTransactions(rawData) {
                const transactions = [];

                for (const row of rawData) {
                    const dateStr = (row['RELEASE_DATE'] || '').trim();
                    const transactionType = (row['TRANSACTION_TYPE'] || '').trim();
                    const referenceId = (row['REFERENCE_ID'] || '').trim();
                    const amountStr = (row['TRANSACTION_NET_AMOUNT'] || '').trim();

                    if (!dateStr) continue;

                    const parsedDate = this.addOneDayAndFormat(dateStr);
                    if (!parsedDate) continue;

                    const cleanType = this.cleanTransactionType(transactionType);

                    const descriptionParts = [];
                    if (cleanType) descriptionParts.push(cleanType);
                    if (referenceId) descriptionParts.push(referenceId);

                    const description = descriptionParts.length > 0
                        ? descriptionParts.join(' - ')
                        : 'Transaction';

                    const amount = this.convertToInteger(amountStr);
                    if (amount === null) continue;

                    transactions.push({
                        date: parsedDate,
                        description: description,
                        amount: amount,
                        currency: 'ARS'
                    });
                }

                return transactions;
            }
        }

        // Helper functions for CSV export and clipboard

        function transactionsToCsv(transactions) {
            const rows = [['date', 'description', 'amount']];

            transactions.forEach(t => {
                const date = `${String(t.date.getDate()).padStart(2, '0')}/${String(t.date.getMonth() + 1).padStart(2, '0')}/${t.date.getFullYear()}`;
                rows.push([date, t.description, t.amount]);
            });

            return rows.map(row => {
                return row.map((cell, idx) => {
                    // Quote all cells to handle commas in descriptions
                    if (idx === 1) { // description column
                        return `"${String(cell).replace(/"/g, '""')}"`;
                    }
                    return cell;
                }).join(',');
            }).join('\n');
        }

        function downloadCsv(csvContent, filename) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function copyToClipboard(text) {
            return navigator.clipboard.writeText(text);
        }

        // Main App Component

        function App() {
            const [bank, setBank] = useState('');
            const [file, setFile] = useState(null);
            const [results, setResults] = useState(null);
            const [error, setError] = useState(null);
            const [processing, setProcessing] = useState(false);
            const [copySuccess, setCopySuccess] = useState({});

            const handleFileChange = (e) => {
                setFile(e.target.files[0]);
                setError(null);
                setResults(null);
                setCopySuccess({});
            };

            const handleBankChange = (e) => {
                setBank(e.target.value);
                setError(null);
                setResults(null);
                setCopySuccess({});
            };

            const handleProcess = async () => {
                if (!bank || !file) {
                    setError('Please select both a bank and a file');
                    return;
                }

                setProcessing(true);
                setError(null);
                setResults(null);
                setCopySuccess({});

                try {
                    let parser;
                    if (bank === 'santander') {
                        parser = new SantanderParser(file);
                    } else if (bank === 'mercadopago') {
                        parser = new MercadoPagoParser(file);
                    } else {
                        throw new Error('Invalid bank selection');
                    }

                    const batches = await parser.parse();
                    setResults(batches);
                } catch (err) {
                    setError(`Error processing file: ${err.message}`);
                } finally {
                    setProcessing(false);
                }
            };

            const handleCopy = async (currency) => {
                const batch = results[currency];
                const csvContent = transactionsToCsv(batch.transactions);

                try {
                    await copyToClipboard(csvContent);
                    setCopySuccess({ ...copySuccess, [currency]: true });
                    setTimeout(() => {
                        setCopySuccess({ ...copySuccess, [currency]: false });
                    }, 2000);
                } catch (err) {
                    setError(`Failed to copy to clipboard: ${err.message}`);
                }
            };

            const handleDownload = (currency) => {
                const batch = results[currency];
                const csvContent = transactionsToCsv(batch.transactions);
                const filename = `transactions_${currency.toLowerCase()}.csv`;
                downloadCsv(csvContent, filename);
            };

            return (
                <div className="container">
                    <h1>Transaction Parser</h1>
                    <p className="subtitle">Parse and export bank transactions from Santander and MercadoPago</p>

                    <div className="info">
                        <strong>Supported formats:</strong> Santander Excel (.xlsx) files and MercadoPago CSV files
                    </div>

                    <div className="form-group">
                        <label htmlFor="bank-select">Select Bank</label>
                        <select
                            id="bank-select"
                            value={bank}
                            onChange={handleBankChange}
                        >
                            <option value="">-- Select a bank --</option>
                            <option value="santander">Santander</option>
                            <option value="mercadopago">MercadoPago</option>
                        </select>
                    </div>

                    <div className="form-group">
                        <label htmlFor="file-input">Upload Transaction File</label>
                        <div className="file-input-wrapper">
                            <input
                                type="file"
                                id="file-input"
                                onChange={handleFileChange}
                                accept={bank === 'santander' ? '.xlsx' : bank === 'mercadopago' ? '.csv' : '*'}
                            />
                            <label htmlFor="file-input" className="file-input-label">
                                {file ? 'âœ“ File selected' : 'Click to select file'}
                            </label>
                        </div>
                        {file && <div className="file-name">ðŸ“„ {file.name}</div>}
                    </div>

                    <button
                        onClick={handleProcess}
                        disabled={!bank || !file || processing}
                    >
                        {processing ? 'Processing...' : 'Process File'}
                    </button>

                    {error && <div className="error">{error}</div>}

                    {results && (
                        <div className="results">
                            <h2>Results</h2>
                            {Object.entries(results).map(([currency, batch]) => (
                                <div key={currency} className="currency-section">
                                    <div className="currency-header">
                                        <div className="currency-title">{currency} Transactions</div>
                                        <div className="transaction-count">
                                            {batch.transactions.length} transactions
                                        </div>
                                    </div>

                                    <div className="transaction-preview">
                                        {batch.transactions.slice(0, 10).map((t, idx) => (
                                            <div key={idx} className="transaction-row">
                                                <div className="transaction-date">
                                                    {`${String(t.date.getDate()).padStart(2, '0')}/${String(t.date.getMonth() + 1).padStart(2, '0')}/${t.date.getFullYear()}`}
                                                </div>
                                                <div className="transaction-desc">{t.description}</div>
                                                <div className={`transaction-amount ${t.amount >= 0 ? 'positive' : 'negative'}`}>
                                                    {t.amount.toLocaleString('en-US')}
                                                </div>
                                            </div>
                                        ))}
                                        {batch.transactions.length > 10 && (
                                            <div style={{textAlign: 'center', marginTop: '10px', color: '#666'}}>
                                                ... and {batch.transactions.length - 10} more transactions
                                            </div>
                                        )}
                                    </div>

                                    <div className="action-buttons">
                                        <button onClick={() => handleCopy(currency)}>
                                            ðŸ“‹ Copy to Clipboard
                                        </button>
                                        <button onClick={() => handleDownload(currency)}>
                                            ðŸ’¾ Download CSV
                                        </button>
                                    </div>

                                    {copySuccess[currency] && (
                                        <div className="success">
                                            âœ“ Copied to clipboard!
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
